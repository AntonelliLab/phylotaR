---
title: "phylotaR Tutorial"
author: "D.J. Bennett"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{phylotaR Tutorial}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

The first step to running a phylogenetic analysis is the identification of overlapping sequences. Often orthology is determined by pairing sequences whose gene names match (e.g. COI sequences with COI sequences, rbcl sequences with rbcl sequences). Problems can arise however if gene names differ between authors, if different gene sections are represented or if sequences are mislabelled. These issues can be especially problematic for large-scale analyses where individual errors cannot be detected.

[PhyLoTa](https://www.ncbi.nlm.nih.gov/pubmed/18570030) is a pipeline that uses an alignment search tool to identify orthologous sequences without the need for gene name matching. For a given parental taxonomic group, the pipeline will search through available sequences hosted on GenBank and identify orthologous sequence clusters. A user is then able to survey the identified clusters and select the ones which best suit their phylogenetic analysis needs, e.g. by selecting the clusters that maximise the number of taxonomic groups.

This R pacakge, `phylotaR`, is an R implementation of this pipeline. In this vignette we will demonstrate how to run PhyLoTa using a small taxonomic group. The pipeline is composed of three automated stages (taxise, download, cluster) and a user-performed stage of cluster selection.


# Installing NCBI BLAST+ Tools

The PhyLoTa pipeline uses BLAST to identify orthologous sequence clusters. In order to run phylotaR, a local copy of the BLAST software must be installed on your computer. **Installing the phylotaR package does not install BLAST, it must be installed separately**. To install BLAST+, please see the NCBI website's [installation instructions](https://www.ncbi.nlm.nih.gov/books/NBK279671/).

# Pipeline

## Setup

For demonstration purposes we will run the pipeline on a small taxonomic group. Because they are charismatic and relatively well-studied, we will select the Night Monkey genus, [Aotus](https://www.ncbi.nlm.nih.gov/Taxonomy/Browser/wwwtax.cgi?mode=Info&id=9504). Now that we have decided on a taxonomic group we need to find out its unique taxonomic ID. This can be looked up by navigating to the [NCBI taxonomy webpage](https://www.ncbi.nlm.nih.gov/taxonomy) and searching 'Aotus'. Doing this, we can see that Aotus ID is **9504**. We will need this number for specifying the parameters in our pipeline.

To begin an analysis, we will need to create a new folder that will contain all the output files generated by `phylotaR`. Since we are running the analysis on the Aotus genus, let's call the folder `aotus/`. Now we have our working directory folder created, we can now open R and run the following code.

```{r setup, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}
library(phylotaR)
wd <- '[YOUR PATH TO AOTUS FOLDER]'
ncbi_dr <- '[YOUR PATH TO NCBI BLAST TOOLS]'
txid <- 9504
setUp(wd=wd, txid=txid, ncbi_dr=ncbi_dr)
```

The above imports the `phylotaR` package and initiates a cache that will contain the pipeline parameters. For this tutorial we will keep the parameters as their default. For more information on the parameters please see the ['Advanced' vignette](phylotaR-advanced.html). `wd` must be a file path to the folder we called `aotus/`. `ncbi_dr` must be a file path to the folder containing all the NCBI BLAST+ tools -- see above 'Installing NCBI BLAST+ Tools'. Depending on your system and how you installed the tools, they may be in your system path in which case you can simply supply '.' to the `ncbi_dr` argument. Running `setUp()` will verify whether the BLAST tools are installed correctly.

## Running

After `setUp()` has been run we can run the pipeline with the following command.

```{r running, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}
run(wd=wd)
```

This will run all the automated stages of the pipeline: taxise, download and cluster. The first of these stages looks up all the taxonomic information available on the descendants of the parent ID provided, `txid`. The second downloads representative sequences for all identified decendants. No additional arguments are required other than `wd` which specifies the working directory that contains the cache and all parameters as set up by `setUp()`. In this folder you will also find a `log.txt` that reports detailed information on the progression of the pipeline as well as all the output files generated by each stage. For more information on the output files please see the ['Advanced' vignette](phylotaR-advanced.html).

## Restarting

The pipeline can be halted and restarted. The cache records all downloaded and generated data by the pipeline. If there is a system crash or the user wishes to halt the program, the pipeline can be restarted from the same point it stopped with the function `restart()`. Additionally, due to the potential aleatoric nature of the pipeline, a user may wish to re-run the pipeline from certain stages. This can be achived by first using `reset()` followed by `restart()`. For example, in the code below a completed pipeline is reset to 'cluster' and then restarted. After running these commands, the pipeline will run as if it has only just completed the download stage. Note, all resets and restarts are recorded in the log.

```{r restarting, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}
reset(wd=wd, stage='cluster')
restart(wd=wd)
```

## Cluster selection

After a pipeline has completed, the identified clusters can be interrogated. In the below code, we generate a clusters object using `genClstrsObj()`. Again, all that is required as an argument is the working directory. The produced object contains cluster and sequence information on all the clusters. The `phylotaR` package has a range of functions for probing clusters in a clusters object. For example, if we want to know how many different taxonomic groups are represented by each cluster we can use `nTaxa()`. In the below example, however, we use `getBestClstsrs()` to identify just a single cluster. This function determines best-ness by weighting first by number of taxonomic groups and second by average sequence length. We can write out our best clusters to fasta format for later analysis using `writeSeqs()`. Note, the filenames are automatically generated as [clstr_id].fasta.

```{r selection, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}
clstrs_obj <- genClstrsObj(wd)
clstr_id <- getBestClstrs(clstrs_obj, n=1)
writeSeqs(clstrs_obj, clstr_id, wd) # writes sequences to [clstr_id] + .fasta
```

## Testing output

We can sanity test our best cluster by running a very quick phylogenetic analysis using mafft and raxml. The below code will use the `clstr_id` cluster to generate an alignment and a tree through R. In order for the code to run, it requires the installation of mafft and raxml and, additionally, may require tweaking to work on your system.

```{r testing, eval=FALSE, message=FALSE, warning=FALSE, include=TRUE, paged.print=FALSE}
library(ape)
system(paste0('mafft --auto ', clstr_id, '.fasta > alignment.fasta'))
system(paste0('raxmlHPC -m GTRGAMMA -f a -N 10 -p 1234 -x 1234 -n aotus -s alignment.fasta'))
tree <- read.tree(file='RAxML_bestTree.aotus')
plot(tree, no.margin=TRUE) # check if the same tax IDs are grouped
```

