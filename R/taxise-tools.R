#' @name dwnldTD
#' @title Download NCBI taxonomy dump
#' @description Download and unpack NCBI
#' taxonomy dump.
#' @param ps Parameters
#' @details If \code{tdpth} is left NULL, downloads
#' the taxdump.tar.gz. Otherwise, manually download
#' the file and provide path.
#' \url{ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz}
#' @export
dwnldTD <- function(ps) {
  # unpack parameters
  wd <- ps[['wd']]
  v <- ps[['v']]
  tdpth <- ps[['tdpth']]
  txdr <- file.path(wd, 'taxonomy')
  if(!file.exists(txdr)) {
    dir.create(txdr)
  }
  if(is.null(tdpth)) {
    info(lvl=1, ps=ps,
         'Downloading NCBI taxdump.tar.gz ...')
    flpth <- file.path(txdr, 'taxdump.tar.gz')
    url <- 'ftp://ftp.ncbi.nlm.nih.gov/pub/taxonomy/taxdump.tar.gz'
    res <- curl::curl_fetch_disk(url=url, path=flpth)
    if(!file.exists(res[['content']])) {
      stop('Download failed. Curl status code [',
           res[['status_code']],']')
    }
    info(lvl=1, ps=ps, 'Done.')
  } else {
    flpth <- tdpth
    if(!file.exists(flpth)) {
      stop('[', flpth, '] does not exist.')
    }
  }
  .untar(tarfile=flpth, files=c('nodes.dmp', 'names.dmp'),
         exdir=txdr)
  expflpths <- c(file.path(txdr, 'nodes.dmp'),
                 file.path(txdr, 'names.dmp'))
  if(!all(file.exists(expflpths))) {
    stop('Failed to unpack [', flpth,']')
  }
}

#' @name genTDObj
#' @title Generate R object from NCBI taxonomy dump
#' @description Generates an interrogable R object
#' from the NCBI taxonomy dump using the \code{CHNOSZ}
#' library. The returned object is a list of taxonomic nodes
#' and names.
#' @param ps Parameters
#' @details Object will be cached.
#' @export
# @Hannes, instead of global env vars, I'm using the cache tools
# to save progress along the way.
genTDObj <- function(ps) {
  # unpack
  wd <- ps[['wd']]
  v <- ps[['v']]
  if(!chkObj(wd, 'tdobj')) {
    info(lvl=1, ps=ps,
         'Reading from taxonomy dump ...')
    if(!file.exists(file.path(wd, 'taxonomy'))) {
      stop('No taxonomy folder in `wd`.')
    }
    nds <- CHNOSZ::getnodes(file.path(wd, 'taxonomy'))
    nms <- CHNOSZ::getnames(file.path(wd, 'taxonomy'))
    tdobj <- list('nds'=nds,
                  'nms'=nms)
    svObj(wd=wd, obj=tdobj, nm='tdobj')
    info(lvl=1, ps=ps, 'Done.')
  } else {
    tdobj <- ldObj(wd, 'tdobj')
  }
  tdobj
}

#' @name genPhylotaNds
#' @title Generate taxonomic nodes in PhyLoTa format
#' @description
#' @param nid_sets Taxonomic processable and unprocessable
#' node IDs, list as generated by \code{getMngblIds}
#' @param v v? T/F
#' @details
#' @export
# @Hannes: this is functional eqv to bulk of nodes.create
genPhylotaNds <- function(nid_sets, td_nds, td_nms, ps) {
  phylt_nds <- data.frame('ti'=NA,
                          'ti_anc'=NA,
                          'rank'=NA,
                          'n_gi_node'=NA,
                          'n_gi_sub_nonmodel'=NA,
                          'n_gi_sub_model'=NA,
                          'n_sp_desc'=NA,
                          'n_sp_model'=NA,
                          'n_leaf_desc'=NA,
                          'n_otu_desc'=NA,
                          'ti_genus'=NA,
                          'n_genera'=NA)
  nids <- nid_sets[['mngbl_ids']]
  info(lvl=1, ps=ps, "Adding [", length(nids),
       "] nodes recursively, in parallel")
  for(i in seq_along(nids)) {
    txid <- nids[i]
    info(lvl=2, ps=ps, "Recursively processing txid [",
         txid, "] [", i, "/", length(nids), "]")
    phylt_nds <- getStats(txid=txid, phylt_nds=phylt_nds,
                          td_nds=td_nds, td_nms=td_nms,
                          ps=ps, rcrsv=TRUE)
    info(lvl=1, ps=ps, "Finished processing txid [",
         txid, "] [", i, "/", length(nids), "]")
  }
  ## Add the top nodes non-recursively. This has to be in reversed
  # order to make sure a parent is not
  ## inserted before it's children, since we need the info from
  # the children. Therefore, this must not
  ## happen in parallel!
  nids <- nid_sets[['rjctd_ids']]
  info(lvl=1, ps=ps, "Adding [", length(nids),
       "] top-level nodes non-recursively, sequentially")
  for (i in seq_along(nids)) {
    txid <- rev(nids)[i] # TODO: how do we know that this will ensure spp?
    info(lvl=2, ps=ps, "Processing txid [",
         txid, "] [", i, "/", length(nids), "]")
    n <- getStats(txid=txid, phylt_nds=phylt_nds,
                  td_nds=td_nds, td_nms=td_nms,
                  rcrsv=FALSE, ps=ps)
    info(lvl=1, ps=ps, "Finished processing txid [",
         txid, "] [", i, "/", length(nids), "]")
  }
  # rm first row
  phylt_nds[-1, ]
}

#' @name getStats
#' @title Generate PhyLoTa statistics for txid
#' @description 
#' @param txid Taxonomic ID
#' @param phylt_nds PhyLoTa data.frame
#' @param td_nds 'nds' element from the \code{tdobj}
#' @param td_nms 'nms' element from the \code{tdobj}
#' @param rcrsv Add stats for kid nodes recursively? T/F
#' @param ps Parameters
#' @details Returns an updated \code{phylt_nds}.
#' @export
# @Hannes: this is functional eqv to get.stats
getStats <- function(txid, phylt_nds, td_nds, td_nms,
                     ps, rcrsv=FALSE) {
  info(lvl=3, ps=ps, "Adding species counts for txid [",
       txid, "]")
  rank <- CHNOSZ::getrank(txid, nodes=td_nds)
  parent <- CHNOSZ::parent(txid, nodes=td_nds)
  genus <- getGenus(txid, td_nds)
  stats <- data.frame(ti=txid,
                      ti_anc=parent,
                      rank=rank,
                      n_gi_node=0,
                      n_gi_sub_model=0,
                      n_gi_sub_nonmodel=0,
                      n_leaf_desc=0, # counts itself, for a leaf it is 1
                      n_sp_desc=0, # counts itself, for a species it is 1
                      n_sp_model=0,
                      ti_genus=genus,
                      n_genera=0,
                      n_otu_desc=1)
  if(rank == 'species') {
    stats['n_sp_desc'] <- 1
  }
  n_drctsqs <- nSqs(txid, direct=TRUE,
                    mx_len=ps[['mxsql']], v=v)
  stats['n_gi_node'] <- n_drctsqs
  kids <- getKids(txid, td_nds=td_nds)
  if(length(kids) == 0) {
    stats['n_leaf_desc'] <- stats['n_leaf_desc'] + 1
  }
  if(n_drctsqs > ps[['mdlt']]) {
    stats['n_gi_sub_model'] <- n_drctsqs
    stats['n_sp_model'] <- stats['n_sp_model'] + 1
  } else {
    stats['n_gi_sub_nonmodel'] <- n_drctsqs
  }
  for(kid in kids) {
    if(rcrsv) {
      phylt_nds <- getStats(txid=kid,
                            phylt_nds=phylt_nds,
                            td_nds=td_nds, td_nms=td_nms,
                            rcrsv=rcrsv, ps=ps)
    }
    # TODO: @Hannes, this section worries me. What if a user
    #  supplies phylt_nds without rows for any kids?
    #  Function crashes.
    # I kept getting kid duplicates, using [1] with `which`
    if(CHNOSZ::getrank(kid, nodes=td_nds) == 'genus') {
      stats['n_genera'] <- stats['n_genera'] + 1
    }
    cols <- c('n_leaf_desc', 'n_otu_desc', 'n_sp_desc',
              'n_sp_model', 'n_genera')
    kid_nd <- phylt_nds[which(phylt_nds[,'ti']==kid)[1],]
    stats['n_gi_sub_model'] <- stats['n_gi_sub_model'] +
      kid_nd['n_gi_sub_model']
    stats['n_gi_sub_nonmodel'] <- stats['n_gi_sub_nonmodel'] +
      kid_nd["n_gi_sub_nonmodel"]
    stats[cols] <- stats[cols] + phylt_nds[
      which(phylt_nds$ti==kid)[1], cols]
    stopifnot(dim(stats)[1]==1)
  }
  info(lvl=3, ps=ps, "Added stats for txid [", txid, "]")
  rbind(phylt_nds, stats[names(phylt_nds)])
}

#' @name getMngblIds
#' @title Identify manageable taxonomic node IDs
#' @description Given a root \code{txid}, return a set of
#' taxonomic node IDs that only have up to a maximum number
#' of descendants.
#' @param txid Taxomomic IDs
#' @param td_nds 'nds' element from the \code{tdobj}
#' @param ps Parameters
#' @details Returns a \code{list}.
#' If there are more descendants than mx_dscndnts or
#' retrieveing the number takes longer than \code{tmout}
#' seconds, the taxonomic ID is discarded and its children
#' are added to the queue.
#' @export
# @Hannes: this is functional eqv to get.manageable.node.set
# @Hannes: why do we need the timeout? Surely, mx_dscndnts
# is sufficient?
getMngblIds <- function(txid, td_nds, ps) {
  queue <- txid
  mngbl_ids <- vector()
  ndscndnts <- vector()
  rjctd_ids <- vector()
  tot <- 0
  while(length(queue) > 0) {
    id <- head(queue, 1)
    queue <- tail(queue, length(queue)-1)
    n <- .evlTmLmt(nDscndnts(id, td_nds),
                   cpu=ps[['tmout']])
    if (is.null(n) || n > ps[['mxd']]) {
      queue <- c(queue, getKids(id, td_nds))
      rjctd_ids <- c(rjctd_ids, id)
      info(lvl=1, ps=ps, "Taxon [", id,
           "] has too many descendants or tmout 
reached counting descendants. Processing child taxa.")
    } else {
      mngbl_ids <- c(mngbl_ids, id)
      ndscndnts <- c(ndscndnts, n)
      info(lvl=1, ps=ps, "Taxon [", id,
           "] has maneagable number of descendants [",
           n, '].')
      tot <- tot + n
      info(lvl=1, ps=ps,
           "Current number of nodes to be processed [", tot, "]")
    }
  }
  # @Hannes: why have ndscendnts and not use them?
  list('mngbl_ids'=mngbl_ids, 'rjctd_ids'=rjctd_ids,
       'ndscndnts'=ndscndnts)
}

#' @name nDscndnts
#' @title Count descendants
#' @description Count the number of children
#' descending from a node in the NCBI taxonomy
#' dump.
#' @param id Taxonomic ID
#' @param td_nds NCBI taxonomic nodes
#' @export
nDscndnts <- function(id, td_nds) {
  queue <- id
  res <- 0
  while (length(queue) > 0) {
    res <- res + length(queue)
    newqueue <- suppressWarnings(foreach(i=seq_along(queue),
                                         .combine=c) %dopar% {
                                           getKids(queue[i], td_nds)
                                         })
    queue <- newqueue
  }
  return(res-1)
}

# TODO: rename -- 'kids' implies tips.
#' @name getKids
#' @title Return descendent IDs
#' @description Return vector of descendent IDs
#' from NCBI taxonomic node
#' @export
# @Hannes: eqv of children()
# TODO: is this really 'children' and not just sub nodes?
getKids <- function(id, td_nds) {
  td_nds$id[which(td_nds$parent==id)]
}

#' @name getGenus
#' @title Return genus ID
#' @description Return vector of descendent IDs
#' from NCBI taxonomic node
#' @export
# @Hannes: eqv of .get.genus()
getGenus <- function(txid, td_nds) {
  lwr_rnks <- c('genus', 'subgenus', 'species group',
                'species subgroup', 'species',
                'subspecies','varietas', 'forma')
  hghr_rnks <- c('superkingdom', 'kingdom', 'subkingdom',
                 'superphylum', 'phylum',
                 'subphylum', 'superclass', 'class',
                 'subclass', 'infraclass', 'superorder',
                 'order', 'suborder', 'infraorder',
                 'parvorder', 'superfamily', 'family',
                 'subfamily', 'tribe', 'subtribe')
  # if rank is already higher than genus,
  #  do not search for it
  crrnt <- CHNOSZ::getrank(txid, nodes=td_nds)
  if(!crrnt  %in% lwr_rnks) {
    return(NA)
  }
  while(crrnt != 'genus') {
    txid <- CHNOSZ::parent(txid, nodes=td_nds)
    crrnt <- CHNOSZ::getrank(txid, nodes=td_nds)
    # some hybrids between genera can have a
    #  subfamily as a parent...
    if(crrnt %in% hghr_rnks) {
      break
    }
  }
  return(txid)
}

#' @name writeTax
#' @title Write out the taxonomic PhyLoTa nodes
#' @description Writes a .tsv file to disk in the 
#' PhyLoTa format for all taxonomic information.
#' @param phylt_nds PhyLoTa nodes as generated by \code{genPhylotaNds}
#' @param td_nms Taxonomic dump names
#' @param fl Filepath
#' @param ps Parameters
#' @export
writeTax <- function(phylt_nds, td_nms, fl, ps) {
  taxon_name<- as.character(td_nms[match(phylt_nds[['ti']], td_nms[['id']]),
                                   "name"])
  commons <- td_nms[grep('common', td_nms[['type']]),]
  common_name <- as.character(commons[['name']][match(phylt_nds[['ti']],
                                                      commons[['id']])])
  if(length(common_name) == 0) {
    common_name <- NA
  }
  res <- data.frame(ti=as.integer(phylt_nds[['ti']]),
                    ti_anc=as.integer(phylt_nds[['ti_anc']]),
                    terminal_flag=NA,
                    rank_flag=as.integer(!phylt_nds[['rank']]=='no rank'),
                    model=NA,
                    taxon_name=taxon_name,
                    common_name=common_name,
                    rank=as.character(phylt_nds[['rank']]),
                    n_gi_node=as.integer(phylt_nds[['n_gi_node']]),
                    n_gi_sub_nonmodel=as.integer(phylt_nds[['n_gi_sub_nonmodel']]),
                    n_gi_sub_model=as.integer(phylt_nds[['n_gi_sub_model']]),
                    n_clust_node=NA,
                    n_clust_sub=NA,
                    n_PIclust_sub=NA,
                    n_sp_desc=as.integer(phylt_nds[['n_sp_desc']]),
                    n_sp_model=as.integer(phylt_nds[['n_sp_model']]),
                    n_leaf_desc=as.integer(phylt_nds[['n_leaf_desc']]),
                    n_otu_desc=as.integer(phylt_nds[['n_otu_desc']]),
                    ti_genus=as.integer(phylt_nds[['ti_genus']]),
                    n_genera=as.integer(phylt_nds[['n_genera']])
  )
  write.table(res, file=fl, sep="\t", row.names=FALSE,
              col.names=TRUE)
  info(lvl=1, ps=ps, "Wrote [", nrow(res), "] nodes to file")
}
